---
title: "SAE - Area Level Model"
subtitle: "Modeling Poverty Rates at the Area Level"
author: "Mamadou S Diallo, Ph.D"
date: today
format:
  html:
    theme: readable
    toc: true
    toc-depth: 3
    code-fold: false
execute:
  echo: true
  warning: false
  message: false
---


```{r}

library(dplyr)
library(emdi)
library(gt)
library(haven)
library(readxl)
library(srvyr)
#library(stringr)
library(tibble)

```


## Wrangling and Combining the Datasets

```{r}

pov_df <- 
  haven::read_sav("../data/eicvmb2020/BASE PAUVRETE.sav") |>
  dplyr::rename_with(tolower) |>
  dplyr::arrange(id01, id02)
  

communes_df <- 
  readxl::read_excel("../data/communes_data.xlsx", sheet="menages") |>
  dplyr::rename_with(tolower) |>
  dplyr::arrange(id_commune, id_menage)

# commune_names_df = readxl::read_excel("../data/communes_data.xlsx", sheet="communes")

```

### Inspecting the Datasets

Definition of the communes

```{r}

dim(communes_df)
head(communes_df)

```

Poverty Survey Data

```{r}

dim(pov_df)

pov_df |>
  dplyr::select(idm, id_zd, id01, id02, id03) |>
  head(7)

```

Merging the datasets to add the communes to the survey data

```{r}

pov_merged_df <- 
  pov_df |>
  dplyr::left_join(
    communes_df,
    by = c("idm" = "id_menage")
  ) |>
  dplyr::mutate(
    poor = ifelse(abs_poor == 1, 1, 0)
  )


pov_merged_df |> 
  dplyr::select(idm, id01, id_commune, nom_commune) |>
  head(7)

```

## Direct (Survey-Based) Estimates

Poverty rate estimates at the commune level using survey weights

```{r}

svy_design_hh <- 
  pov_merged_df |>
  srvyr::as_survey_design(
    ids = id_zd,
    strata = c(id01, milieu),
    weights = weight
  )


svy_est_pov_abs <- 
  svy_design_hh |>
  group_by(id_commune, nom_commune) |>
  summarize(
    pov_rate = survey_mean(poor, vartype = c("se", "ci", "cv"), level = 0.95)
  )

svy_est_pov_abs

```

Histogram of the survey-based CVs

```{r}

hist(
  svy_est_pov_abs$pov_rate_cv,
  main = "Histogram of Survey-based CVs of Poverty Rate Estimates",
  xlab = "Coefficient of Variation (CV)",
  col = "lightblue",
  border = "black",
  breaks=c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)
)

```

List of communes with high CVs (> 30%)

```{r}

high_cv_communes <- 
  svy_est_pov_abs |>
  filter(pov_rate_cv > 0.3)


high_cv_communes |>
  dplyr::select(-pov_rate_low, -pov_rate_upp) |>
  dplyr::arrange(desc(pov_rate_cv)) |>
  gt::gt() |>
  gt::fmt_percent(
    columns = c(pov_rate, pov_rate_cv),
    decimals = 1
  ) |>
  gt::cols_label(
    nom_commune = "Commune",
    pov_rate = "Poverty Rate (%)",
    pov_rate_cv = "CV (%)"
  )
```


## Auxiliary Variables

As seen before, we need to identify auxiliary variables at the area level (commune level for us) that are:      

 - **correlated with the target variable** (poverty status),     
 - **available from census or administrative data or Big data**.


For illustration, we will consider these auxiliary variables available from census data at the commune level:

 - `urbain_rate` : Proportion of urban households (or population)
 - `avg_hhsize` : Average household size
 - `acces_electricite` : Rate of access to electricity
 - `cattle_rate` : Proportion de households with cattle


```{r}

hh_census <- 
  haven::read_sav("../data/rgph2008/habit.sav") |>
  dplyr::rename_with(tolower) |>
  dplyr::select(
    commune, urhabit, population, h07, h16a
  ) |>
  dplyr::mutate(
    commune = as.integer(commune)
  )

head(hh_census) |> gt::gt()

```

Creating the indicators

```{r}

hh_census <- 
  hh_census |>
  dplyr::mutate(
    urbain = ifelse(urhabit == 1, 1, 0),
    electricite = ifelse(h07 == 1, 1, 0)
  ) |>
  dplyr::rename(
    cattle = h16a,
    hhsize = population
  )

head(hh_census) |> gt::gt()

```

Estimate the auxiliary variables at the commune level

```{r}

census_aux <- 
  hh_census |>
  dplyr::group_by(commune) |>
  dplyr::summarise(
    urbain_rate = mean(urbain, na.rm=TRUE),
    avg_hhsize = mean(hhsize, na.rm=TRUE),
    acces_electricite = mean(electricite, na.rm=TRUE),
    cattle_rate = mean(cattle, na.rm=TRUE)
  )


head(census_aux, 9) |> gt::gt()
```


## Merging the Auxliary Data to the Survey Data

**Issue**: Some communes in the sample are not in the census. Maybe, it is a nomenclature issue.

```{r}

communes_not_in_census <- 
  svy_est_pov_abs |>
  dplyr::filter(
    !(id_commune %in% census_aux$commune)
  )

head(communes_not_in_census) |> gt::gt()

```

Let's exclude these communes for now

What are the common communes between the two datasets?

```{r}

intersect_communes <- 
  intersect(
    svy_est_pov_abs$id_commune,
    census_aux$commune
  )

```

Let's filter both datasets to keep only these communes and then combine them

```{r}

svy_est_pov_abs2 <- 
  svy_est_pov_abs |>
  dplyr::filter(
    id_commune %in% intersect_communes
  )

census_aux2 <- 
  census_aux |>
  dplyr::filter(
    commune %in% intersect_communes
  )

combined_df <- emdi::combine_data(
  pop_data = census_aux2,
  pop_domains = "commune",
  smp_data = svy_est_pov_abs2,
  smp_domains = "id_commune"
) |>
  dplyr::mutate(
    pov_rate_variance = pov_rate_se^2
  )

head(combined_df, 9) |> gt::gt()

```


## Area Level Model Estimation

**Model 1.**

```{r}

amodel_pov_abs1 <- 
  emdi::fh(
    fixed = pov_rate ~ urbain_rate + avg_hhsize + acces_electricite + cattle_rate,
    vardir = "pov_rate_variance",
    combined_data = combined_df,
    domains = "id_commune", 
    method = "reml",
    MSE = TRUE
  )

amodel_pov_abs1
summary(amodel_pov_abs1)

```

**Model 2.**

```{r}

amodel_pov_abs2 <- 
  emdi::fh(
    fixed = pov_rate ~ urbain_rate + avg_hhsize + cattle_rate,
    vardir = "pov_rate_variance",
    combined_data = combined_df,
    domains = "id_commune", 
    method = "reml",
    MSE = TRUE
  )

amodel_pov_abs2
summary(amodel_pov_abs2)

```


**Model 3.**

```{r}

amodel_pov_abs3 <- 
  emdi::fh(
    fixed = pov_rate ~ urbain_rate + avg_hhsize,
    vardir = "pov_rate_variance",
    combined_data = combined_df,
    domains = "id_commune", 
    method = "reml",
    MSE = TRUE
  )

amodel_pov_abs3
summary(amodel_pov_abs3)

```


## Comparisons

Let's compare the model selection statistics

```{r}

dplyr::bind_rows(
  amodel_pov_abs1$model$model_select,
  amodel_pov_abs2$model$model_select,
  amodel_pov_abs3$model$model_select
) |>
  gt::gt()

```

Let's select model 2 and compare the estimates with the survey-based estimates

```{r}

amodel_pov_abs2$ind |>
ggplot2::ggplot() +
  ggplot2::geom_point(
    ggplot2::aes(x = Direct, y = FH),
    color = "blue",
    alpha = 0.5
  ) +
  ggplot2::geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  ggplot2::labs(
    title = "Comparison of Survey-based and Model-based Poverty Rate Estimates",
    x = "Survey-based Estimates",
    y = "Model-based Estimates"
  ) +
  ggplot2::theme_minimal()

```

How about the residuals ?

```{r}

amodel_pov_abs2$model$real_residuals |>
  tibble::tibble(.name_repair = make.names ) |>
  dplyr::rename(
    real_residuals = amodel_pov_abs2.model.real_residuals
  ) |>
  ggplot2::ggplot() +
  ggplot2::geom_histogram(
    ggplot2::aes(x = real_residuals),
    bins = 20,
    fill = "lightgreen",
    color = "black"
  ) +
  ggplot2::labs(
    title = "Histogram of Residuals from Area Level Model",
    x = "Residuals",
    y = "Frequency"
  ) +
  ggplot2::theme_minimal()

```

Noise graph of the residuals

```{r}

amodel_pov_abs2$model$real_residuals |>
  tibble::tibble(.name_repair = make.names ) |>
  dplyr::rename(
    real_residuals = amodel_pov_abs2.model.real_residuals
  ) |>
  dplyr::mutate(
    index = dplyr::row_number()
  ) |>
  ggplot2::ggplot() +
  ggplot2::geom_point(
    ggplot2::aes(x = index, y = real_residuals),
    color = "purple",
    alpha = 0.6
  ) +
  ggplot2::geom_hline(yintercept = 0, linetype = "dashed") +
  ggplot2::labs(
    title = "Noise Graph of Residuals from Area Level Model",
    x = "Index",
    y = "Residuals"
  ) +
  ggplot2::theme_minimal() 

```

## Did the CVs Improve ?

```{r}

amodel_pov_abs2$MSE |>
ggplot2::ggplot() +
  ggplot2::geom_point(
    ggplot2::aes(x = Direct, y = FH),
    color = "blue",
    alpha = 0.5
  ) +
  ggplot2::geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
  ggplot2::labs(
    title = "Comparison of Survey-based and Model-based Poverty Rate MSE Estimates",
    x = "Survey-based Estimates",
    y = "Model-based Estimates"
  ) +
  ggplot2::theme_minimal()

```

Direct and modelled in the same graph and color by type 

```{r}

amodel_pov_abs2$MSE |>
  tidyr::pivot_longer(
    cols = c(Direct, FH),
    names_to = "Estimate_Type",
    values_to = "MSE_Value"
  ) |>
  ggplot2::ggplot() +
  ggplot2::geom_point(
    ggplot2::aes(x = reorder(Domain, -MSE_Value), y = MSE_Value, color = Estimate_Type),
    alpha = 0.7
  ) +
  ggplot2::labs(
    title = "Comparison of Survey-based and Model-based Poverty Rate MSE Estimates by Commune",
    x = "Commune",
    y = "MSE Value",
    color = "Estimate Type"
  ) +
  ggplot2::theme_minimal() +
  ggplot2::theme(
    axis.text.x = ggplot2::element_blank()
  )

```


Ratio FH over Direct of the MSEs and order them from the highest to lowest

```{r}

amodel_pov_abs2$MSE |>
  dplyr::mutate(
    MSE_Ratio = FH / Direct
  ) |>
  dplyr::arrange(desc(MSE_Ratio)) |>
  dplyr::mutate(
    Domain = factor(Domain, levels = Domain)
  ) |>
  ggplot2::ggplot() +
  ggplot2::geom_bar(
    ggplot2::aes(x = Domain, y = MSE_Ratio),
    stat = "identity",
    fill = "steelblue"
  ) +
  ggplot2::labs(
    title = "Ratio of Model-based to Survey-based Poverty Rate MSE Estimates by Commune",
    x = "Commune",
    y = "MSE Ratio (FH / Direct)"
  ) +
  ggplot2::theme_minimal() +
  ggplot2::theme(
    axis.text.x = ggplot2::element_blank()
  )

```


We can show the top five and bottow five rations in a table

```{r}

full_table <- 
  amodel_pov_abs2$MSE |>
  dplyr::mutate(
    MSE_Ratio = FH / Direct
  ) |>
  dplyr::arrange(desc(MSE_Ratio)) |>
  dplyr::select(Domain, Direct, FH, MSE_Ratio) |>
  dplyr::rename(
    Commune = Domain,
    Survey_Based_MSE = Direct,
    Model_Based_MSE = FH,
    MSE_Ratio_FH_to_Direct = MSE_Ratio
  ) |>
  dplyr::bind_rows(
    amodel_pov_abs2$MSE |>
      dplyr::mutate(
        MSE_Ratio = FH / Direct
      ) |>
      dplyr::arrange(MSE_Ratio) |>
      dplyr::select(Domain, Direct, FH, MSE_Ratio) |>
      dplyr::rename(
        Commune = Domain,
        Survey_Based_MSE = Direct,
        Model_Based_MSE = FH,
        MSE_Ratio_FH_to_Direct = MSE_Ratio
      ) |>
      dplyr::slice_head(n = 5)
  ) |>
  dplyr::arrange(desc(MSE_Ratio_FH_to_Direct))

top_10 <-
  full_table |>
  head(10)
  
bottom_10 <-
  full_table |>
  tail(10)
  
  
  dplyr::bind_rows(
    top_10,
    bottom_10
  ) |>
  gt::gt() |>
  gt::fmt_number(
    columns = c(Survey_Based_MSE, Model_Based_MSE),
    decimals = 4,
    scale_by = 1000
  ) |>
  gt::fmt_number(
    columns = c(MSE_Ratio_FH_to_Direct),
    decimals = 2
  ) |>
      gt::cols_label(
        Survey_Based_MSE = "Direct (x1000)",
        Model_Based_MSE = "FH (x1000)",
        MSE_Ratio_FH_to_Direct = "Ratio: FH / Direct"
      ) 

```


Largest CVs

```{r}

est <- amodel_pov_abs2$ind |>
  dplyr::select(Domain, Direct, FH) |>
  dplyr::rename(
    est_direct = Direct,
    est_fh = FH
  )

mse <- amodel_pov_abs2$MSE |>
  dplyr::select(Domain, Direct, FH) |>
  dplyr::rename(
    mse_direct = Direct,
    mse_fh = FH
  )
  
cvs <- est |>
  dplyr::inner_join(
    mse,
    by = "Domain"
  ) |>
  dplyr::mutate(
    cv_direct = sqrt(mse_direct) / (est_direct + 1e-10),
    cv_model = sqrt(mse_fh) / (est_fh + 1e-10),
  ) |>  
  dplyr::arrange(desc(cv_direct))


cvs |>
  gt::gt() |>
  gt::fmt_percent(
    columns = c(cv_direct, cv_model),
    decimals = 1
  ) |>
  gt::cols_label(
    Domain = "Commune",
    est_direct = "Direct Estimate",
    est_fh = "Model Estimate",
    cv_direct = "Direct CV",
    cv_model = "Model CV"
  )

```

